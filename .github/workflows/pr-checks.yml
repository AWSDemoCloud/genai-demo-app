name: PR Enhancement Suite

on:
  pull_request:
    types: [opened, synchronize, reopened]

# Define environment variables at the workflow level
env:
  MODEL_ID: "anthropic.claude-3-sonnet-20240229-v1:0"
  MAX_TOKENS: "1024"
  AWS_REGION: "${{ secrets.AWS_REGION }}"

permissions:
  id-token: write          # OIDC for AWS
  contents: write          # checkout / diff / commit changes
  pull-requests: write     # for posting comments
  checks: write            # for posting check results

jobs:
  amazon-q-review:
    name: ❶ Amazon Q Code Review
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Only need minimal history for PR changes
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: amazon-q-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Create diff for Amazon Q
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > changed_files.txt
          git diff --text ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > q-diff.txt
          echo "Diff size: $(stat -c%s q-diff.txt || wc -c < q-diff.txt) bytes"
      
      - name: Install AWS CLI v2
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws --version
      
      - name: Run Amazon Q Business Security Scan
        id: q-review
        run: |
          echo "Running Amazon Q Business security scan..."
          
          # Trigger GitHub repository sync
          echo "Syncing GitHub repository with Amazon Q Business..."
          SYNC_RESPONSE=$(aws qbusiness start-data-source-sync-job \
            --application-id "${{ secrets.Q_APP_ID }}" \
            --index-id "${{ secrets.Q_INDEX_ID }}" \
            --data-source-id "${{ secrets.Q_DATA_SOURCE_ID }}" \
            --output json) || {
              echo "Repository sync failed, continuing with alternative approach..."
              echo "review-status=sync-failed" >> $GITHUB_OUTPUT
            }
          
          # Extract sync job ID and monitor status
          if [ -n "$SYNC_RESPONSE" ]; then
            SYNC_JOB_ID=$(echo $SYNC_RESPONSE | jq -r '.jobId')
            echo "Sync job started with ID: $SYNC_JOB_ID"
            
            # Wait for sync to complete with timeout and status monitoring
            echo "Waiting for sync to complete..."
            MAX_RETRIES=12
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              SYNC_STATUS=$(aws qbusiness list-data-source-sync-jobs \
                --application-id "${{ secrets.Q_APP_ID }}" \
                --index-id "${{ secrets.Q_INDEX_ID }}" \
                --data-source-id "${{ secrets.Q_DATA_SOURCE_ID }}" \
                --query "dataSourceSyncJobs[?jobId=='$SYNC_JOB_ID'].status" \
                --output text) || break
              
              echo "Sync status: $SYNC_STATUS (attempt $RETRY_COUNT of $MAX_RETRIES)"
              
              if [ "$SYNC_STATUS" = "SUCCEEDED" ]; then
                echo "Sync completed successfully"
                break
              elif [[ "$SYNC_STATUS" = "FAILED" || "$SYNC_STATUS" = "ABORTED" ]]; then
                echo "Sync failed with status: $SYNC_STATUS"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 10
            done
          fi
          
          # Run security scan using Amazon Q Business
          echo "Running code security scan..."
          aws qbusiness query \
            --application-id "${{ secrets.Q_APP_ID }}" \
            --user-id "${{ secrets.Q_USER_ID }}" \
            --input-text "Scan the repository for security vulnerabilities and provide a detailed JSON report" \
            --output json > q-review-raw.json || {
              echo "Amazon Q Business scan failed, using fallback"
              echo "review-status=scan-failed" >> $GITHUB_OUTPUT
            }        
      
      - name: Process Amazon Q Findings
        run: |
          echo "Processing Amazon Q Developer findings..."
          
          # Check if the scan produced results
          if [ -f "q-review-raw.json" ] && [ -s "q-review-raw.json" ]; then
            echo "Amazon Q scan completed successfully"
            
            # Process the raw output
            jq '{
              summary: (.findings | length | tostring) + " security findings detected",
              issues: .findings | map({
                severity: (if .severity == "HIGH" then "high" else if .severity == "MEDIUM" then "medium" else "low" end),
                message: (.title + ": " + .description),
                location: (.filePath + ":" + (.startLine | tostring))
              }),
              suggestions: .findings | map({
                file: .filePath,
                line: .startLine,
                message: .recommendation
              }),
              scanId: .scanId,
              scanTime: .scanTime
            }' q-review-raw.json > q-review.json || {
              echo "Failed to process JSON results, creating minimal report"
              echo '{
                "summary": "Amazon Q scan completed but results processing failed",
                "issues": [{"severity": "info", "message": "Failed to process scan results"}],
                "suggestions": []
              }' > q-review.json
            }
          else
            echo '{
              "summary": "Amazon Q scan failed to produce results",
              "issues": [{"severity": "info", "message": "Amazon Q scan failed. Check AWS configuration."}],
              "suggestions": []
            }' > q-review.json
            echo "review-status=no-results" >> $GITHUB_OUTPUT
          fi
      
      - name: Post Amazon Q Review as Check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let rawReview;
            
            try {
              rawReview = JSON.parse(fs.readFileSync('q-review.json', 'utf8'));
            } catch (error) {
              console.error('Error reading review file:', error);
              rawReview = {
                summary: 'Failed to read Amazon Q review results',
                issues: [{severity: 'info', message: 'Failed to read review results'}],
                suggestions: []
              };
            }
            
            // Format and post check
            // [Detailed check formatting code would go here]
            
            // Post comment for high severity issues only
            const hasHighSeverity = rawReview.issues && 
              rawReview.issues.some(i => ['critical', 'high'].includes(i.severity));
              
            if (hasHighSeverity) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `## Amazon Q Code Review - Security Alert\n\nHigh severity issues detected in PR #${context.payload.pull_request.number}. Please review the detailed findings in the PR checks.`
              });
            }

  build-and-test:
    name: ❷ Build & Test
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node (LTS) + cache
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        working-directory: app
        run: npm ci --no-audit --no-fund --loglevel=error

      - name: Run Jest tests
        id: run-tests
        working-directory: app
        run: |
          npm test -- --runInBand --detectOpenHandles --forceExit --ci || {
            echo "Tests failed with exit code $?"
            echo "test-status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "test-status=passed" >> $GITHUB_OUTPUT

  bedrock-docs:
    name: ❸ Bedrock Documentation Generator
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() || failure() # Run even if tests fail, but not if they error
    timeout-minutes: 10
    outputs:
      doc-generated: ${{ steps.doc-generation.outputs.doc-generated }}
      doc-path: ${{ steps.doc-generation.outputs.doc-path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper diff

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: docs-bot-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create diff file
        id: create-diff
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git fetch origin ${{ github.head_ref }}:${{ github.head_ref }}
          git checkout ${{ github.head_ref }}
          
          # Try merge-base diff first
          git diff --text --diff-filter=d ${{ github.base_ref }}...${{ github.head_ref }} > diff.txt || true
          
          # Fallback: if empty, use direct HEAD~1 comparison
          if [[ ! -s diff.txt ]]; then
            echo "No merge-base diff found; using HEAD~1 comparison."
            git diff --text HEAD~1 > diff.txt || true
          fi
          
          # Validate diff file
          if [[ ! -s diff.txt ]]; then
            echo "Empty diff file - skipping documentation generation"
            echo "diff-status=empty" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Binary file check
          if file -I "diff.txt" | grep -q -v "text/"; then
            echo "ERROR: Diff contains binary data!"
            echo "diff-status=binary" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "diff-status=valid" >> $GITHUB_OUTPUT
          echo "Diff size: $(stat -c%s diff.txt || wc -c < diff.txt) bytes"

      - name: Generate PR Documentation
        id: doc-generation
        if: steps.create-diff.outputs.diff-status == 'valid'
        run: |
          # Install dependencies
          pip install --no-cache-dir boto3
          
          # Make the script executable
          chmod +x scripts/bedrock-pr-docs.py
          
          # Generate documentation
          python scripts/bedrock-pr-docs.py diff.txt doc.md --model-id "${{ env.MODEL_ID }}" || {
            echo "Failed to generate documentation"
            echo "doc-generated=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          # Verify output
          if [ -f doc.md ] && [ -s doc.md ]; then
            echo "doc-generated=true" >> $GITHUB_OUTPUT
            echo "doc-path=doc.md" >> $GITHUB_OUTPUT
          else
            echo "doc-generated=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit documentation
        if: success() && steps.doc-generation.outputs.doc-generated == 'true'
        run: |
          git config --global user.name "PR Documentation Bot"
          git config --global user.email "bot@example.com"
          
          git add doc.md
          git commit -m "📝 Auto-generated docs for PR #${{ github.event.pull_request.number }}" || {
            echo "Nothing to commit - documentation unchanged"
            exit 0
          }
          
          # Push with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin HEAD:${{ github.head_ref }}; then
              echo "Successfully pushed documentation"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed, retrying in 5 seconds..."
                sleep 5
                git pull --rebase origin ${{ github.head_ref }}
              else
                echo "Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

  pr-narrator:
    name: ❹ PR Narrator
    runs-on: ubuntu-latest
    needs: [amazon-q-review, bedrock-docs]
    if: always() && !cancelled()
    timeout-minutes: 5
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: pr-narrator-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Determine Lambda function name
        id: lambda-function
        run: |
          # Get Lambda function name from CloudFormation stack with error handling
          LAMBDA_FUNCTION=$(aws cloudformation describe-stacks --stack-name genai-pr-enhancement --query "Stacks[0].Outputs[?OutputKey=='PRNarratorFunction'].OutputValue" --output text) || {
            echo "Failed to get Lambda function name from CloudFormation"
            echo "function-name=pr-narrator" >> $GITHUB_OUTPUT
            exit 0
          }
          
          # Use fallback if empty
          if [ -z "$LAMBDA_FUNCTION" ]; then
            echo "Could not find Lambda function ARN. Using default name"
            echo "function-name=pr-narrator" >> $GITHUB_OUTPUT
          else
            echo "Found Lambda function: $LAMBDA_FUNCTION"
            echo "function-name=$LAMBDA_FUNCTION" >> $GITHUB_OUTPUT
          fi
      
      - name: Invoke PR-Narrator Lambda
        id: invoke-lambda
        run: |
          # Create payload with proper error handling for docs status
          DOC_GENERATED="${{ needs.bedrock-docs.outputs.doc-generated || 'false' }}"
          
          echo '{
            "pr_number": "${{ github.event.pull_request.number }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.event.pull_request.head.sha }}",
            "doc_generated": "'$DOC_GENERATED'"
          }' > lambda-payload.json
          
          # Invoke Lambda with timeout
          timeout 30s aws lambda invoke \
            --function-name "${{ steps.lambda-function.outputs.function-name }}" \
            --payload file://lambda-payload.json \
            --cli-binary-format raw-in-base64-out \
            lambda-response.json || {
              echo "Lambda invocation failed or timed out"
              echo '{
                "statusCode": 500,
                "body": {
                  "audio_url": "",
                  "summary": "Failed to generate PR summary. Lambda function timed out or failed."
                }
              }' > lambda-response.json
              echo "lambda-status=failed" >> $GITHUB_OUTPUT
            }
          
          # Process response
          if [ -f lambda-response.json ] && [ -s lambda-response.json ]; then
            # Extract values with error handling
            AUDIO_URL=$(jq -r '.body.audio_url // ""' lambda-response.json || echo "")
            jq -r '.body.summary // "PR summary not available"' lambda-response.json > summary.txt || echo "PR summary not available" > summary.txt
            
            if [ -n "$AUDIO_URL" ]; then
              echo "audio-url=$AUDIO_URL" >> $GITHUB_OUTPUT
              echo "lambda-status=success" >> $GITHUB_OUTPUT
            else
              echo "audio-url=" >> $GITHUB_OUTPUT
              echo "lambda-status=no-audio" >> $GITHUB_OUTPUT
            fi
          else
            echo "Empty or missing Lambda response"
            echo "audio-url=" >> $GITHUB_OUTPUT
            echo "lambda-status=no-response" >> $GITHUB_OUTPUT
          fi
      
      - name: Post PR Comment with Audio Summary
        if: steps.invoke-lambda.outputs.lambda-status == 'success'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = "PR summary not available";
            
            try {
              summary = fs.readFileSync('summary.txt', 'utf8');
            } catch (error) {
              console.error('Error reading summary file:', error);
            }
            
            const audioUrl = process.env.AUDIO_URL;
            
            let commentBody = `## 🎙️ PR #${context.payload.pull_request.number} Audio Summary\n\n`;
            commentBody += summary;
            
            if (audioUrl) {
              commentBody += `\n\n[🔊 Listen to the audio summary](${audioUrl})\n\n`;
            }
            
            commentBody += '*Generated by PR-Narrator using AWS Bedrock Sonic*';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
        env:
          AUDIO_URL: ${{ steps.invoke-lambda.outputs.audio-url }}
