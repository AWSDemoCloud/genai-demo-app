name: PR Enhancement Suite

on:
  pull_request:
    types: [opened, synchronize, reopened]

# Define environment variables at the workflow level
env:
  MODEL_ID: "anthropic.claude-3-sonnet-20240229-v1:0"
  MAX_TOKENS: "1024"
  AWS_REGION: "${{ secrets.AWS_REGION }}"

permissions:
  id-token: write          # OIDC for AWS
  contents: write          # checkout / diff / commit changes
  pull-requests: write     # for posting comments
  checks: write            # for posting check results

jobs:
  amazon-q-review:
    name: ‚ù∂ Amazon Q Code Review
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      issues-detected: ${{ steps.process-findings.outputs.issues-detected }}
      issues-file: ${{ steps.process-findings.outputs.issues-file }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Only need minimal history for PR changes
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: amazon-q-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Create diff for Amazon Q
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > changed_files.txt
          git diff --text ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > q-diff.txt
          echo "Diff size: $(stat -c%s q-diff.txt || wc -c < q-diff.txt) bytes"
      
      - name: Install AWS CLI v2
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws --version
      
      - name: Run Amazon Q Business Security Scan
        id: q-review
        run: |
          echo "Running Amazon Q Business security scan..."
          
          # Trigger GitHub repository sync
          echo "Syncing GitHub repository with Amazon Q Business..."
          SYNC_RESPONSE=$(aws qbusiness start-data-source-sync-job \
            --application-id "${{ secrets.Q_APP_ID }}" \
            --index-id "${{ secrets.Q_INDEX_ID }}" \
            --data-source-id "${{ secrets.Q_DATA_SOURCE_ID }}" \
            --output json) || {
                echo "Repository sync failed, continuing with alternative approach..."
                echo "review-status=sync-failed" >> $GITHUB_OUTPUT
              }
          
          # Extract sync job ID and monitor status with better error handling
          if [ -n "$SYNC_RESPONSE" ]; then
            SYNC_JOB_ID=$(echo $SYNC_RESPONSE | jq -r '.jobId // .executionId // ""')
            echo "Sync job started with ID: $SYNC_JOB_ID"
            
            if [ -n "$SYNC_JOB_ID" ]; then
              # Wait for sync to complete with timeout and status monitoring
              echo "Waiting for sync to complete..."
              MAX_RETRIES=12
              RETRY_COUNT=0
              
              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                SYNC_STATUS=$(aws qbusiness list-data-source-sync-jobs \
                  --application-id "${{ secrets.Q_APP_ID }}" \
                  --index-id "${{ secrets.Q_INDEX_ID }}" \
                  --data-source-id "${{ secrets.Q_DATA_SOURCE_ID }}" \
                  --query "dataSourceSyncJobs[?jobId=='$SYNC_JOB_ID'].status || history[?executionId=='$SYNC_JOB_ID'].status" \
                  --output text) || break
                
                echo "Sync status: $SYNC_STATUS (attempt $RETRY_COUNT of $MAX_RETRIES)"
                
                if [ "$SYNC_STATUS" = "SUCCEEDED" ]; then
                  echo "Sync completed successfully"
                  break
                elif [[ "$SYNC_STATUS" = "FAILED" || "$SYNC_STATUS" = "ABORTED" ]]; then
                  echo "Sync failed with status: $SYNC_STATUS"
                  break
                fi
                
                RETRY_COUNT=$((RETRY_COUNT+1))
                sleep 10
              done
            else
              echo "Warning: Could not extract job ID from response, skipping sync status check"
            fi
          fi
          
          # Run security scan using Amazon Q Business with correct command
          echo "Running code security scan..."
          aws qbusiness chat-sync \
            --application-id "${{ secrets.Q_APP_ID }}" \
            --user-message "Scan the repository for security vulnerabilities and provide a detailed JSON report" \
            --output json > q-review-raw.json || {
              echo "Amazon Q Business scan failed, using fallback"
              echo "review-status=scan-failed" >> $GITHUB_OUTPUT
            }
      
      - name: Process Amazon Q Findings
        id: process-findings
        run: |
          echo "Processing Amazon Q Developer findings..."
          
          # Check if the scan produced results
          if [ -f "q-review-raw.json" ] && [ -s "q-review-raw.json" ]; then
            # Extract the relevant parts from the response
            jq -r '.messages[1].content' q-review-raw.json > q-review-content.txt || {
              echo "Failed to extract content from Q response"
              echo "review-status=extraction-failed" >> $GITHUB_OUTPUT
              echo '{
                "summary": "Failed to extract content from Amazon Q response",
                "issues": [{"severity": "info", "message": "Failed to extract content from response"}],
                "suggestions": []
              }' > q-review.json
              echo "issues-detected=false" >> $GITHUB_OUTPUT
              echo "issues-file=q-review.json" >> $GITHUB_OUTPUT
              exit 0
            }
            
            # Try to extract JSON from the response content
            cat q-review-content.txt | grep -o '{.*}' > q-review-json.txt || {
              echo "Failed to extract JSON from content"
              echo "review-status=json-extraction-failed" >> $GITHUB_OUTPUT
              echo '{
                "summary": "Failed to extract JSON from Amazon Q response",
                "issues": [{"severity": "info", "message": "Failed to extract JSON from content"}],
                "suggestions": []
              }' > q-review.json
              echo "issues-detected=false" >> $GITHUB_OUTPUT
              echo "issues-file=q-review.json" >> $GITHUB_OUTPUT
              exit 0
            }
            
            # Validate and format the JSON
            jq '.' q-review-json.txt > q-review.json || {
              echo "Invalid JSON format in response"
              echo "review-status=invalid-json" >> $GITHUB_OUTPUT
              echo '{
                "summary": "Invalid JSON format in Amazon Q response",
                "issues": [{"severity": "info", "message": "Failed to process scan results"}],
                "suggestions": []
              }' > q-review.json
              echo "issues-detected=false" >> $GITHUB_OUTPUT
              echo "issues-file=q-review.json" >> $GITHUB_OUTPUT
              exit 0
            }
            
            # Check if there are any issues that can be fixed
            ISSUE_COUNT=$(jq '.issues | length' q-review.json || echo "0")
            if [ "$ISSUE_COUNT" -gt 0 ]; then
              echo "Found $ISSUE_COUNT issues to analyze for potential fixes"
              echo "issues-detected=true" >> $GITHUB_OUTPUT
            else
              echo "No issues detected that need fixing"
              echo "issues-detected=false" >> $GITHUB_OUTPUT
            fi
            
            # Create a structured issues file for the auto-fix job
            jq '{ "issues": .issues, "suggestions": .suggestions }' q-review.json > q-issues.json
            echo "issues-file=q-issues.json" >> $GITHUB_OUTPUT
          else
            echo '{
              "summary": "Amazon Q scan failed to produce results",
              "issues": [{"severity": "info", "message": "Amazon Q scan failed. Check AWS configuration."}],
              "suggestions": []
            }' > q-review.json
            echo "review-status=no-results" >> $GITHUB_OUTPUT
            echo "issues-detected=false" >> $GITHUB_OUTPUT
            echo "issues-file=q-review.json" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload review artifacts
        uses: actions/upload-artifact@v3
        with:
          name: q-review-artifacts
          path: |
            q-review.json
            q-issues.json
          retention-days: 1
      
      - name: Post Amazon Q Review as Check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let rawReview;
            
            try {
              rawReview = JSON.parse(fs.readFileSync('q-review.json', 'utf8'));
            } catch (error) {
              console.error('Error reading review file:', error);
              rawReview = {
                summary: 'Failed to read Amazon Q review results',
                issues: [{severity: 'info', message: 'Failed to read review results'}],
                suggestions: []
              };
            }
            
            // Format and post check
            // [Detailed check formatting code would go here]
            
            // Post comment for high severity issues only
            const hasHighSeverity = rawReview.issues && 
              rawReview.issues.some(i => ['critical', 'high'].includes(i.severity));
              
            if (hasHighSeverity) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `## Amazon Q Code Review - Security Alert\n\nHigh severity issues detected in PR #${context.payload.pull_request.number}. Please review the detailed findings in the PR checks.`
              });
            }

  auto-fix-issues:
    name: ‚ù∑ Auto-Fix Code Issues
    runs-on: ubuntu-latest
    needs: amazon-q-review
    if: needs.amazon-q-review.outputs.issues-detected == 'true'
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for PR
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: auto-fix-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download issues file
        uses: actions/download-artifact@v3
        with:
          name: q-review-artifacts
          path: ./
      
      - name: Analyze issues and generate fixes
        id: generate-fixes
        run: |
          echo "Analyzing issues to generate automatic fixes..."
          
          # Read the issues file
          ISSUES_FILE="${{ needs.amazon-q-review.outputs.issues-file }}"
          if [ ! -f "$ISSUES_FILE" ]; then
            echo "Issues file not found: $ISSUES_FILE"
            echo "fix-status=no-issues-file" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create a directory for fix scripts
          mkdir -p fixes
          
          # Extract issues that can be automatically fixed
          FIXABLE_ISSUES=$(jq '.issues[] | select(.severity == "low" or .severity == "info") | select(.location != null)' "$ISSUES_FILE")
          FIXABLE_COUNT=$(echo "$FIXABLE_ISSUES" | grep -c "severity" || echo "0")
          
          if [ "$FIXABLE_COUNT" -eq 0 ]; then
            echo "No automatically fixable issues found"
            echo "fix-status=no-fixable-issues" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Found $FIXABLE_COUNT potentially fixable issues"
          
          # Process each fixable issue
          echo "$FIXABLE_ISSUES" | jq -c '.' | while read -r issue; do
            SEVERITY=$(echo "$issue" | jq -r '.severity')
            MESSAGE=$(echo "$issue" | jq -r '.message')
            LOCATION=$(echo "$issue" | jq -r '.location')
            
            # Parse location to get file and line
            FILE=$(echo "$LOCATION" | cut -d ':' -f 1)
            LINE=$(echo "$LOCATION" | cut -d ':' -f 2)
            
            if [ -f "$FILE" ]; then
              echo "Generating fix for issue in $FILE:$LINE - $MESSAGE"
              
              # Get context around the issue (10 lines before and after)
              LINE_START=$((LINE - 10))
              if [ $LINE_START -lt 1 ]; then LINE_START=1; fi
              LINE_END=$((LINE + 10))
              
              # Extract code context
              CODE_CONTEXT=$(sed -n "${LINE_START},${LINE_END}p" "$FILE")
              
              # Create a prompt for Bedrock to generate a fix
              PROMPT="You are an expert code reviewer and fixer. Please analyze the following code issue and provide a fix:\n\nFile: $FILE\nLine: $LINE\nIssue: $MESSAGE\nSeverity: $SEVERITY\n\nCode context:\n\n```\n$CODE_CONTEXT\n```\n\nPlease provide:\n1. A brief explanation of the issue\n2. The exact code that needs to be changed\n3. The corrected code\n4. A sed command that can be used to apply the fix\n\nFormat your response as a JSON object with the following fields: explanation, original_code, fixed_code, sed_command"
              
              # Call Bedrock to generate a fix
              aws bedrock-runtime invoke-model \
                --model-id "$MODEL_ID" \
                --body "{\"anthropic_version\": \"bedrock-2023-05-31\", \"max_tokens\": 1024, \"messages\": [{\"role\": \"user\", \"content\": \"$PROMPT\"}]}" \
                --cli-binary-format raw-in-base64-out \
                fixes/response_$(echo "$FILE" | tr '/' '_')_$LINE.json
              
              # Extract the fix from the response
              jq -r '.messages[0].content' fixes/response_$(echo "$FILE" | tr '/' '_')_$LINE.json > fixes/fix_$(echo "$FILE" | tr '/' '_')_$LINE.txt
            else
              echo "File not found: $FILE"
            fi
          done
          
          # Count how many fixes were generated
          FIX_COUNT=$(ls fixes/fix_* 2>/dev/null | wc -l || echo "0")
          echo "Generated $FIX_COUNT potential fixes"
          
          if [ "$FIX_COUNT" -gt 0 ]; then
            echo "fix-status=fixes-generated" >> $GITHUB_OUTPUT
            echo "fix-count=$FIX_COUNT" >> $GITHUB_OUTPUT
          else
            echo "fix-status=no-fixes-generated" >> $GITHUB_OUTPUT
            echo "fix-count=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Apply fixes
        if: steps.generate-fixes.outputs.fix-status == 'fixes-generated'
        id: apply-fixes
        run: |
          echo "Applying generated fixes..."
          
          # Initialize counters
          APPLIED=0
          FAILED=0
          
          # Process each fix file
          for FIX_FILE in fixes/fix_*.txt; do
            echo "Processing fix: $FIX_FILE"
            
            # Extract the JSON part from the fix file
            JSON_CONTENT=$(cat "$FIX_FILE" | grep -o '{.*}' || echo "{}")
            
            if [ "$JSON_CONTENT" != "{}" ]; then
              # Extract components from the JSON
              FILE=$(echo "$JSON_CONTENT" | jq -r '.file // ""')
              ORIGINAL=$(echo "$JSON_CONTENT" | jq -r '.original_code // ""')
              FIXED=$(echo "$JSON_CONTENT" | jq -r '.fixed_code // ""')
              SED_CMD=$(echo "$JSON_CONTENT" | jq -r '.sed_command // ""')
              
              # If file path not provided, extract it from filename
              if [ -z "$FILE" ]; then
                FILE_PART=$(basename "$FIX_FILE" | sed 's/fix_//g' | sed 's/\.txt$//g')
                FILE=$(echo "$FILE_PART" | tr '_' '/')
              fi
              
              if [ -f "$FILE" ] && [ -n "$ORIGINAL" ] && [ -n "$FIXED" ]; then
                echo "Applying fix to $FILE"
                
                # Create a temporary file with the fix
                TEMP_FILE="$(mktemp)"
                
                # Try to apply the fix using sed if provided
                if [ -n "$SED_CMD" ]; then
                  # Extract the sed expression
                  SED_EXPR=$(echo "$SED_CMD" | sed -n 's/.*sed -i ["'\'']\(.*\)["'\'']\s\+["'\'']\(.*\)["'\'']\s\+\(.*\)/\1/p')
                  
                  if [ -n "$SED_EXPR" ]; then
                    # Apply sed command to create fixed file
                    sed "$SED_EXPR" "$FILE" > "$TEMP_FILE"
                  else
                    # Fallback to direct replacement
                    cat "$FILE" | sed "s/$(echo "$ORIGINAL" | sed 's/[\[\]\$\*\.\/]/\\&/g')/$(echo "$FIXED" | sed 's/[\[\]\$\*\.\/]/\\&/g')/g" > "$TEMP_FILE"
                  fi
                else
                  # Fallback to direct replacement
                  cat "$FILE" | sed "s/$(echo "$ORIGINAL" | sed 's/[\[\]\$\*\.\/]/\\&/g')/$(echo "$FIXED" | sed 's/[\[\]\$\*\.\/]/\\&/g')/g" > "$TEMP_FILE"
                fi
                
                # Check if the fix was applied successfully
                if cmp -s "$FILE" "$TEMP_FILE"; then
                  echo "No changes were made to $FILE"
                  FAILED=$((FAILED+1))
                else
                  # Apply the fix
                  cp "$TEMP_FILE" "$FILE"
                  echo "Successfully applied fix to $FILE"
                  APPLIED=$((APPLIED+1))
                fi
                
                # Clean up
                rm -f "$TEMP_FILE"
              else
                echo "Missing required information for fix: file=$FILE, has_original=$([ -n "$ORIGINAL" ] && echo "yes" || echo "no"), has_fixed=$([ -n "$FIXED" ] && echo "yes" || echo "no")"
                FAILED=$((FAILED+1))
              fi
            else
              echo "Could not extract JSON from fix file: $FIX_FILE"
              FAILED=$((FAILED+1))
            fi
          done
          
          echo "Applied $APPLIED fixes successfully, $FAILED fixes failed"
          echo "applied-count=$APPLIED" >> $GITHUB_OUTPUT
          echo "failed-count=$FAILED" >> $GITHUB_OUTPUT
          
          if [ "$APPLIED" -gt 0 ]; then
            echo "fix-applied=true" >> $GITHUB_OUTPUT
          else
            echo "fix-applied=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit and push fixes
        if: steps.apply-fixes.outputs.fix-applied == 'true'
        run: |
          # Configure git
          git config --global user.name "Amazon Q Auto-Fix Bot"
          git config --global user.email "auto-fix-bot@example.com"
          
          # Stage changes
          git add .
          
          # Commit with a descriptive message
          git commit -m "ü§ñ Auto-fix: Applied ${{ steps.apply-fixes.outputs.applied-count }} fixes to code issues
          
          Automatically fixed low-severity code issues detected by Amazon Q Developer.
          These changes address best practices, code style, and minor bugs."
          
          # Push changes
          git push origin ${{ github.event.pull_request.head.ref }}
      
      - name: Post fix summary comment
        if: steps.generate-fixes.outputs.fix-status == 'fixes-generated'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const appliedCount = parseInt('${{ steps.apply-fixes.outputs.applied-count || 0 }}');
            const failedCount = parseInt('${{ steps.apply-fixes.outputs.failed-count || 0 }}');
            const totalCount = appliedCount + failedCount;
            
            let commentBody = `## ü§ñ Amazon Q Auto-Fix Summary\n\n`;
            
            if (appliedCount > 0) {
              commentBody += `‚úÖ Successfully applied **${appliedCount}** automatic fixes to code issues detected in this PR.\n\n`;
              commentBody += `These changes address best practices, code style, and minor bugs. The fixes have been committed directly to this PR.\n\n`;
            } else {
              commentBody += `‚ö†Ô∏è Generated **${totalCount}** potential fixes, but none could be automatically applied.\n\n`;
              commentBody += `Please review the issues manually and consider addressing them in your code.\n\n`;
            }
            
            if (failedCount > 0) {
              commentBody += `‚ÑπÔ∏è **${failedCount}** potential fixes could not be automatically applied and may require manual intervention.\n\n`;
            }
            
            commentBody += `*This automated fix was powered by Amazon Q Developer and AWS Bedrock.*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });

  build-and-test:
    name: ‚ù∏ Build & Test
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node (LTS) + cache
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        working-directory: app
        run: npm ci --no-audit --no-fund --loglevel=error

      - name: Run Jest tests
        id: run-tests
        working-directory: app
        run: |
          npm test -- --runInBand --detectOpenHandles --forceExit --ci || {
            echo "Tests failed with exit code $?"
            echo "test-status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "test-status=passed" >> $GITHUB_OUTPUT

  bedrock-docs:
    name: ‚ù∏ Bedrock Documentation Generator
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() || failure() # Run even if tests fail, but not if they error
    timeout-minutes: 10
    outputs:
      doc-generated: ${{ steps.doc-generation.outputs.doc-generated }}
      doc-path: ${{ steps.doc-generation.outputs.doc-path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper diff

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: docs-bot-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create diff file
        id: create-diff
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git fetch origin ${{ github.head_ref }}:${{ github.head_ref }}
          git checkout ${{ github.head_ref }}
          
          # Try merge-base diff first
          git diff --text --diff-filter=d ${{ github.base_ref }}...${{ github.head_ref }} > diff.txt || true
          
          # Fallback: if empty, use direct HEAD~1 comparison
          if [[ ! -s diff.txt ]]; then
            echo "No merge-base diff found; using HEAD~1 comparison."
            git diff --text HEAD~1 > diff.txt || true
          fi
          
          # Validate diff file
          if [[ ! -s diff.txt ]]; then
            echo "Empty diff file - skipping documentation generation"
            echo "diff-status=empty" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Binary file check
          if file -I "diff.txt" | grep -q -v "text/"; then
            echo "ERROR: Diff contains binary data!"
            echo "diff-status=binary" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "diff-status=valid" >> $GITHUB_OUTPUT
          echo "Diff size: $(stat -c%s diff.txt || wc -c < diff.txt) bytes"

      - name: Generate PR Documentation
        id: doc-generation
        if: steps.create-diff.outputs.diff-status == 'valid'
        run: |
          # Install dependencies
          pip install --no-cache-dir boto3
          
          # Make the script executable
          chmod +x scripts/bedrock-pr-docs.py
          
          # Generate documentation
          python scripts/bedrock-pr-docs.py diff.txt doc.md --model-id "${{ env.MODEL_ID }}" || {
            echo "Failed to generate documentation"
            echo "doc-generated=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          # Verify output
          if [ -f doc.md ] && [ -s doc.md ]; then
            echo "doc-generated=true" >> $GITHUB_OUTPUT
            echo "doc-path=doc.md" >> $GITHUB_OUTPUT
          else
            echo "doc-generated=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit documentation
        if: success() && steps.doc-generation.outputs.doc-generated == 'true'
        run: |
          git config --global user.name "PR Documentation Bot"
          git config --global user.email "bot@example.com"
          
          git add doc.md
          git commit -m "üìù Auto-generated docs for PR #${{ github.event.pull_request.number }}" || {
            echo "Nothing to commit - documentation unchanged"
            exit 0
          }
          
          # Push with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin HEAD:${{ github.head_ref }}; then
              echo "Successfully pushed documentation"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed, retrying in 5 seconds..."
                sleep 5
                git pull --rebase origin ${{ github.head_ref }}
              else
                echo "Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

  pr-narrator:
    name: ‚ùπ PR Narrator
    runs-on: ubuntu-latest
    needs: [amazon-q-review, bedrock-docs]
    if: always() && !cancelled()
    timeout-minutes: 5
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: pr-narrator-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Determine Lambda function name
        id: lambda-function
        run: |
          # Get Lambda function name from CloudFormation stack with error handling
          LAMBDA_FUNCTION=$(aws cloudformation describe-stacks --stack-name genai-pr-enhancement --query "Stacks[0].Outputs[?OutputKey=='PRNarratorFunction'].OutputValue" --output text) || {
            echo "Failed to get Lambda function name from CloudFormation"
            echo "function-name=pr-narrator" >> $GITHUB_OUTPUT
            exit 0
          }
          
          # Use fallback if empty
          if [ -z "$LAMBDA_FUNCTION" ]; then
            echo "Could not find Lambda function ARN. Using default name"
            echo "function-name=pr-narrator" >> $GITHUB_OUTPUT
          else
            echo "Found Lambda function: $LAMBDA_FUNCTION"
            echo "function-name=$LAMBDA_FUNCTION" >> $GITHUB_OUTPUT
          fi
      
      - name: Invoke PR-Narrator Lambda
        id: invoke-lambda
        run: |
          # Create payload with proper error handling for docs status
          DOC_GENERATED="${{ needs.bedrock-docs.outputs.doc-generated || 'false' }}"
          
          echo '{
            "pr_number": "${{ github.event.pull_request.number }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.event.pull_request.head.sha }}",
            "doc_generated": "'$DOC_GENERATED'"
          }' > lambda-payload.json
          
          # Invoke Lambda with timeout
          timeout 30s aws lambda invoke \
            --function-name "${{ steps.lambda-function.outputs.function-name }}" \
            --payload file://lambda-payload.json \
            --cli-binary-format raw-in-base64-out \
            lambda-response.json || {
              echo "Lambda invocation failed or timed out"
              echo '{
                "statusCode": 500,
                "body": {
                  "audio_url": "",
                  "summary": "Failed to generate PR summary. Lambda function timed out or failed."
                }
              }' > lambda-response.json
              echo "lambda-status=failed" >> $GITHUB_OUTPUT
            }
          
          # Process response
          if [ -f lambda-response.json ] && [ -s lambda-response.json ]; then
            # Extract values with error handling
            AUDIO_URL=$(jq -r '.body.audio_url // ""' lambda-response.json || echo "")
            jq -r '.body.summary // "PR summary not available"' lambda-response.json > summary.txt || echo "PR summary not available" > summary.txt
            
            if [ -n "$AUDIO_URL" ]; then
              echo "audio-url=$AUDIO_URL" >> $GITHUB_OUTPUT
              echo "lambda-status=success" >> $GITHUB_OUTPUT
            else
              echo "audio-url=" >> $GITHUB_OUTPUT
              echo "lambda-status=no-audio" >> $GITHUB_OUTPUT
            fi
          else
            echo "Empty or missing Lambda response"
            echo "audio-url=" >> $GITHUB_OUTPUT
            echo "lambda-status=no-response" >> $GITHUB_OUTPUT
          fi
      
      - name: Post PR Comment with Audio Summary
        if: steps.invoke-lambda.outputs.lambda-status == 'success'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let summary = "PR summary not available";
            
            try {
              summary = fs.readFileSync('summary.txt', 'utf8');
            } catch (error) {
              console.error('Error reading summary file:', error);
            }
            
            const audioUrl = process.env.AUDIO_URL;
            
            let commentBody = `## üéôÔ∏è PR #${context.payload.pull_request.number} Audio Summary\n\n`;
            commentBody += summary;
            
            if (audioUrl) {
              commentBody += `\n\n[üîä Listen to the audio summary](${audioUrl})\n\n`;
            }
            
            commentBody += '*Generated by PR-Narrator using AWS Bedrock Sonic*';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
        env:
          AUDIO_URL: ${{ steps.invoke-lambda.outputs.audio-url }}
