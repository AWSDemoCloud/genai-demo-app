name: PR Enhancement Suite

on:
  pull_request:
    types: [opened, synchronize, reopened]

# Define environment variables at the workflow level
env:
  MODEL_ID: "anthropic.claude-3-sonnet-20240229-v1:0"
  MAX_TOKENS: "1024"

permissions:
  id-token: write          # OIDC for AWS
  contents: write          # checkout / diff / commit changes
  pull-requests: write     # let the auto‑docs job push commits
  checks: write            # allow posting check results

jobs:
# ──────────────────────────────────────────────────────────────
  amazon-q-review:
    name: ❶ Amazon Q Code Review
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: amazon-q-${{ github.run_id }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Create diff for Amazon Q
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git diff --text --diff-filter=d ${{ github.base_ref }}...HEAD > q-diff.txt
          echo "Diff size: $(stat -c%s q-diff.txt || wc -c < q-diff.txt) bytes"
      
      - name: Run Amazon Q Code Review
        id: q-review
        run: |
          # Set up Amazon Q CLI (if needed)
          # aws q-dev-agent install || true
          
          # Run code review
          echo "Running Amazon Q code review..."
          # aws q-dev-agent review --diff-file q-diff.txt --output-file q-review.json
          
          # For demo, simulate the review output with security findings
          echo '{
            "summary":"Security review identified multiple critical issues in the code changes. Found hardcoded credentials, SQL injection vulnerabilities, command injection risks, and insecure data handling.",
            "issues":[
              {"severity":"critical","message":"Hardcoded credentials detected in app/index.js","location":"app/index.js:9-10"},
              {"severity":"critical","message":"SQL injection vulnerability in database query","location":"app/index.js:58"},
              {"severity":"high","message":"Command injection vulnerability in executeCommand function","location":"app/index.js:40-42"},
              {"severity":"high","message":"Insecure random number generation for session IDs","location":"app/index.js:74"},
              {"severity":"high","message":"Sensitive data exposure in error messages","location":"app/index.js:132-134"},
              {"severity":"medium","message":"Prototype pollution vulnerability in user configuration handling","location":"app/index.js:77-79"},
              {"severity":"medium","message":"Insecure HTTP request without TLS verification","location":"app/index.js:133-135"},
              {"severity":"medium","message":"API key exposed in HTTP headers","location":"app/index.js:136-138"}
            ],
            "suggestions":[
              {"file":"app/index.js","line":9,"message":"Remove hardcoded credentials and use environment variables or a secure secret management service"},
              {"file":"app/index.js","line":58,"message":"Use parameterized queries or an ORM to prevent SQL injection"},
              {"file":"app/index.js","line":40,"message":"Validate and sanitize user input before using in command execution"},
              {"file":"app/index.js","line":74,"message":"Use crypto.randomBytes() for generating secure random values"},
              {"file":"app/index.js","line":132,"message":"Avoid exposing detailed error information to users"}
            ],
            "securityIssues":[
              {"severity":"critical","description":"Hardcoded API keys and database credentials","remediation":"Store secrets in environment variables or use AWS Secrets Manager"},
              {"severity":"critical","description":"SQL injection through unsanitized user input","remediation":"Use parameterized queries and input validation"},
              {"severity":"high","description":"Command injection vulnerability","remediation":"Use allowlists and proper input sanitization for system commands"},
              {"severity":"high","description":"Insecure authentication mechanism","remediation":"Implement proper password hashing with bcrypt or Argon2"},
              {"severity":"medium","description":"Sensitive data logging","remediation":"Implement proper data masking for sensitive information in logs"}
            ]
          }' > q-review.json
          
          echo "review-status=completed" >> $GITHUB_OUTPUT
      
      - name: Post Amazon Q Review as Check
        if: steps.q-review.outputs.review-status == 'completed'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const review = JSON.parse(fs.readFileSync('q-review.json', 'utf8'));
            
            // Determine check conclusion based on issues
            const hasCritical = review.issues && review.issues.some(i => i.severity === 'critical');
            const hasHigh = review.issues && review.issues.some(i => i.severity === 'high');
            
            // Set conclusion based on severity
            let conclusion = 'success';
            if (hasCritical) {
              conclusion = 'failure';
            } else if (hasHigh) {
              conclusion = 'neutral';
            }
            
            // Create check output with enhanced security information
            const output = {
              title: 'Amazon Q Security Review',
              summary: review.summary || 'Code review completed',
              text: '## Security Analysis Results\n\n'
            };
            
            // Add security badge based on findings
            if (hasCritical) {
              output.text += '⛔ **CRITICAL SECURITY ISSUES DETECTED** ⛔\n\n';
            } else if (hasHigh) {
              output.text += '⚠️ **HIGH SEVERITY SECURITY ISSUES DETECTED** ⚠️\n\n';
            } else {
              output.text += '✅ **NO CRITICAL SECURITY ISSUES DETECTED** ✅\n\n';
            }
            
            // Add issues section with severity grouping
            if (review.issues && review.issues.length > 0) {
              output.text += '### Security Issues\n\n';
              
              // Group issues by severity
              const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
              const issuesBySeverity = {};
              
              review.issues.forEach(issue => {
                const severity = issue.severity || 'info';
                if (!issuesBySeverity[severity]) {
                  issuesBySeverity[severity] = [];
                }
                issuesBySeverity[severity].push(issue);
              });
              
              // Add issues in order of severity
              severityOrder.forEach(severity => {
                if (issuesBySeverity[severity] && issuesBySeverity[severity].length > 0) {
                  const emoji = severity === 'critical' ? '🔴' : 
                               severity === 'high' ? '🟠' :
                               severity === 'medium' ? '🟡' :
                               severity === 'low' ? '🔵' : 'ℹ️';
                  
                  output.text += `#### ${emoji} ${severity.toUpperCase()} Severity Issues\n\n`;
                  issuesBySeverity[severity].forEach(issue => {
                    output.text += `- **${issue.message}**\n`;
                    if (issue.location) {
                      output.text += `  - Location: \`${issue.location}\`\n`;
                    }
                  });
                  output.text += '\n';
                }
              });
            } else {
              output.text += '### Issues\n\nNo issues found\n\n';
            }
            
            // Add suggestions section
            output.text += '### Remediation Suggestions\n\n';
            if (review.suggestions && review.suggestions.length > 0) {
              review.suggestions.forEach(s => {
                output.text += `- **${s.file}:${s.line}**: ${s.message}\n`;
              });
            } else {
              output.text += 'No suggestions\n';
            }
            
            // Add detailed security issues section if available
            if (review.securityIssues && review.securityIssues.length > 0) {
              output.text += '\n### Detailed Security Analysis\n\n';
              review.securityIssues.forEach(issue => {
                const severityEmoji = issue.severity === 'critical' ? '🔴' : 
                                     issue.severity === 'high' ? '🟠' :
                                     issue.severity === 'medium' ? '🟡' : '🔵';
                
                output.text += `#### ${severityEmoji} ${issue.description}\n\n`;
                if (issue.remediation) {
                  output.text += `**Remediation:** ${issue.remediation}\n\n`;
                }
              });
            }
            
            // Add security best practices section
            output.text += '\n### Security Best Practices\n\n';
            output.text += '1. **Never store credentials in code** - Use environment variables or a secrets manager\n';
            output.text += '2. **Always validate user input** - Prevent injection attacks\n';
            output.text += '3. **Use parameterized queries** - Prevent SQL injection\n';
            output.text += '4. **Implement proper authentication** - Use secure password hashing\n';
            output.text += '5. **Secure your API endpoints** - Validate all requests\n';
            
            // Post check
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Amazon Q Security Review',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: conclusion,
              output: output
            });
            
            // Post PR comment for critical/high issues
            if (hasCritical || hasHigh) {
              // Count critical and high issues directly from the review data
              const criticalCount = review.issues ? review.issues.filter(i => i.severity === 'critical').length : 0;
              const highCount = review.issues ? review.issues.filter(i => i.severity === 'high').length : 0;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `## ⚠️ Security Alert: ${criticalCount} critical and ${highCount} high severity issues detected\n\n${review.summary}\n\n[View detailed security analysis in PR checks](${context.payload.repository.html_url}/pull/${context.payload.pull_request.number}/checks)`
              });
            }

# ──────────────────────────────────────────────────────────────
  build-and-test:
    name: Build & Jest
    runs-on: ubuntu-latest
    timeout-minutes: 5
    continue-on-error: true      # demo keeps flowing even on red tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node (LTS) + cache
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            app/package-lock.json

      - name: Install deps
        working-directory: app
        run: |
          npm ci --no-audit --no-fund --loglevel=error

      - name: Run Jest (force‑exit)
        working-directory: app
        run: |
          npm test -- --runInBand --detectOpenHandles --forceExit || true

# ──────────────────────────────────────────────────────────────
  bedrock-docs:
    name: ❷ Bedrock Agent (Documentation)
    runs-on: ubuntu-latest
    needs: build-and-test
    timeout-minutes: 10
    outputs:
      doc-generated: ${{ steps.doc-generation.outputs.doc-generated }}
      doc-path: ${{ steps.doc-generation.outputs.doc-path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- Debug info (size of diff + jq path) ---------------
      - name: Pre‑flight debug
        run: |
          which jq || true
          echo "jq version:" $(jq --version || echo "missing")
          echo "HEAD is" $(git rev-parse --short HEAD)

      # --- Configure AWS creds via OIDC ----------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: docs-bot-${{ github.run_id }}
          aws-region: ${{ secrets.AWS_REGION }}

      # --- Build a robust diff -------------------------------
      - name: Create diff file
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          git fetch origin ${{ github.head_ref }}:${{ github.head_ref }}
          git checkout ${{ github.head_ref }}
          git diff --text --diff-filter=d ${{ github.base_ref }}...${{ github.head_ref }} > diff.txt || true  # <-- KEY CHANGE HERE
      
          if [[ ! -s diff.txt ]]; then
            echo "No merge-base diff; using HEAD~1."
            git diff --text HEAD~1 > diff.txt || true
          fi
      
          # Add binary check
          if file -I "diff.txt" | grep -q -v "text/"; then
            echo "ERROR: Diff contains binary data!"
            exit 1
          fi
      
          echo "First 10 lines of diff:"
          head -n 10 diff.txt || true
          echo "Diff size:" $(stat -c%s diff.txt || echo 0) "bytes"

      # --- Invoke Bedrock agent / model ----------------------
      - name: Generate PR Documentation
        id: doc-generation
        if: ${{ hashFiles('diff.txt') != '' }}
        env:
          MODEL_ID: "anthropic.claude-3-sonnet-20240229-v1:0"
          MAX_TOKENS: "1024"
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          # Install boto3 if needed
          pip install boto3
          
          # Make the Python script executable
          chmod +x scripts/bedrock-pr-docs.py
          
          # Generate documentation
          python scripts/bedrock-pr-docs.py diff.txt doc.md --model-id "$MODEL_ID"
          
          # Set outputs for PR-Narrator using the new environment file approach
          if [ -f doc.md ]; then
            echo "doc-generated=true" >> $GITHUB_OUTPUT
            echo "doc-path=doc.md" >> $GITHUB_OUTPUT
          else
            echo "doc-generated=false" >> $GITHUB_OUTPUT
          fi

      # --- Commit auto‑generated docs ------------------------
      - name: Commit documentation
        if: success() && ${{ hashFiles('doc.md') != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git config --global user.name  "rahulladumor-ai"
          git config --global user.email "ladumorrahul56@gmail.com"
          if [ -f doc.md ]; then
            git add doc.md
            git commit -m "🤖 Auto-generated docs via Bedrock" || echo "Nothing to commit"
            git push origin HEAD:${{ github.head_ref }}
          else
            echo "No doc.md to commit."
          fi
      
# ──────────────────────────────────────────────────────────────
  pr-narrator:
    name: ❸ Lambda PR-Narrator
    runs-on: ubuntu-latest
    needs: [amazon-q-review, bedrock-docs]
    if: always() # Run even if previous jobs failed
    timeout-minutes: 5
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: pr-narrator-${{ github.run_id }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Invoke PR-Narrator Lambda
        id: invoke-lambda
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_NAME: ${{ github.repository }}
          DOC_GENERATED: ${{ needs.bedrock-docs.outputs.doc-generated || 'false' }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          # Create payload for Lambda
          echo '{"pr_number": "'$PR_NUMBER'", "repository": "'$REPO_NAME'", "commit_sha": "'$COMMIT_SHA'", "doc_generated": "'$DOC_GENERATED'"}' > lambda-payload.json
          
          echo "Payload content:"
          cat lambda-payload.json
          
          # Get Lambda function name from CloudFormation stack
          LAMBDA_FUNCTION=$(aws cloudformation describe-stacks --stack-name genai-pr-enhancement --query "Stacks[0].Outputs[?OutputKey=='PRNarratorFunction'].OutputValue" --output text)
          
          if [ -z "$LAMBDA_FUNCTION" ]; then
            echo "Could not find Lambda function ARN. Using default name 'pr-narrator'"
            LAMBDA_FUNCTION="pr-narrator"
          else
            echo "Found Lambda function: $LAMBDA_FUNCTION"
          fi
          
          # Invoke Lambda function
          echo "Invoking PR-Narrator Lambda..."
          aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION" \
            --payload file://lambda-payload.json \
            --cli-binary-format raw-in-base64-out \
            lambda-response.json
          
          # For demo purposes, simulate the Lambda response if it doesn't exist
          if [ ! -f lambda-response.json ]; then
            echo '{"statusCode": 200, "body": {"audio_url": "https://example.com/pr-summary.mp3", "summary": "PR adds improved diff handling with text mode and binary file detection."}}' > lambda-response.json
          fi
          
          # Extract audio URL and summary
          AUDIO_URL=$(cat lambda-response.json | jq -r '.body.audio_url // "https://example.com/pr-summary.mp3"')
          SUMMARY=$(cat lambda-response.json | jq -r '.body.summary // "PR summary not available"')
          
          # Store the summary in a file instead of using GitHub outputs
          echo "$SUMMARY" > summary.txt
          
          # Only use GitHub Actions output for the audio URL
          echo "audio-url=$AUDIO_URL" >> $GITHUB_OUTPUT
      
      - name: Post PR Comment with Audio Summary
        if: steps.invoke-lambda.outputs.audio-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const audioUrl = process.env.AUDIO_URL;
            
            // Read summary directly from file
            const summary = fs.readFileSync('summary.txt', 'utf8');
            
            console.log('Audio URL: ' + audioUrl);
            console.log('Summary length: ' + summary.length);
            
            let commentBody = '## 🎙️ PR Audio Summary\n\n';
            commentBody += summary;
            commentBody += '\n\n[🔊 Listen to the audio summary](' + audioUrl + ')\n\n';
            commentBody += '*Generated by PR-Narrator using AWS Bedrock Nova Sonic*';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
        env:
          AUDIO_URL: ${{ steps.invoke-lambda.outputs.audio-url }}
      
